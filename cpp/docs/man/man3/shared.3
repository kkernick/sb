.TH "shared" 3 "SB++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
shared \- Shared functionality\&.  

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBTemporaryDirectory\fP"
.br
.RI "A Temporary Directory A directory that destroys itself upon falling out of scope\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBset\fP = std::set<std::string>"
.br
.ti -1c
.RI "using \fBvector\fP = std::vector<std::string>"
.br
.ti -1c
.RI "using \fBlist\fP = std::initializer_list<std::string_view>"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlog\fP (const list &msg, const std::string &level='log')"
.br
.RI "Log output to console, if verbose\&. "
.ti -1c
.RI "bool \fBcontains\fP (const char &v, const char &d)"
.br
.ti -1c
.RI "bool \fBcontains\fP (const char &v, const std::string_view &d)"
.br
.ti -1c
.RI "void \fBemplace\fP (std::set< std::string > &working, const std::string_view &val)"
.br
.ti -1c
.RI "void \fBemplace\fP (std::vector< std::string > &working, const std::string_view &val)"
.br
.ti -1c
.RI "template<class T> std::string \fBjoin\fP (const T &list, const char &joiner=' ')"
.br
.RI "Join a vector into a string\&. "
.ti -1c
.RI "template std::string \fBjoin\fP (const list &, const char &)"
.br
.ti -1c
.RI "template std::string \fBjoin\fP (const vector &, const char &)"
.br
.ti -1c
.RI "template std::string \fBjoin\fP (const set &, const char &)"
.br
.ti -1c
.RI "template<typename T> std::string \fBstrip\fP (const std::string_view &in, const T &to_strip)"
.br
.RI "Strip all instance of character from a string\&. "
.ti -1c
.RI "template std::string \fBstrip\fP (const std::string_view &, const char &)"
.br
.ti -1c
.RI "template std::string \fBstrip\fP (const std::string_view &, const std::string_view &)"
.br
.ti -1c
.RI "template<typename T> std::string \fBtrim\fP (const std::string &in, const T &to_strip)"
.br
.RI "Trim characters from the front and end of a string\&. "
.ti -1c
.RI "template std::string \fBtrim\fP (const std::string &, const char &)"
.br
.ti -1c
.RI "template std::string \fBtrim\fP (const std::string &, const std::string_view &)"
.br
.ti -1c
.RI "set \fBwildcard\fP (const std::string_view &pattern, const std::string_view &path, const list &args={})"
.br
.RI "Resolve wildcard patterns\&. "
.ti -1c
.RI "void \fBgenv\fP (vector &command, const std::string_view &env)"
.br
.RI "Attach an environment variable to the sandbox\&. "
.ti -1c
.RI "template<class T> void \fBextend\fP (vector &dest, T source)"
.br
.RI "Extend a container in place\&. "
.ti -1c
.RI "template void \fBextend\fP (vector &, list)"
.br
.ti -1c
.RI "template void \fBextend\fP (vector &, vector)"
.br
.ti -1c
.RI "template void \fBextend\fP (vector &, set)"
.br
.ti -1c
.RI "template<class T> void \fBextend\fP (set &dest, const T source)"
.br
.ti -1c
.RI "template void \fBextend\fP (set &, const list)"
.br
.ti -1c
.RI "template void \fBextend\fP (set &, const vector)"
.br
.ti -1c
.RI "void \fBextend\fP (set &dest, set source)"
.br
.ti -1c
.RI "void \fBinotify_wait\fP (const int &wd, const std::string_view &name='')"
.br
.RI "Wait for an inotify watcher\&. "
.ti -1c
.RI "void \fBshare\fP (vector &command, const std::string_view &path, const std::string &mode='ro\-bind')"
.br
.RI "Share a path with the sandbox using a mode\&. "
.ti -1c
.RI "std::string \fBhash\fP (const std::string_view &in)"
.br
.RI "Hash a string\&. "
.ti -1c
.RI "std::string \fBescape\fP (const std::string &in)"
.br
.RI "Escape a string\&. "
.ti -1c
.RI "void \fBmerge\fP (set &command, set path)"
.br
.RI "Merge two sets together\&. "
.ti -1c
.RI "template<class T, class A, class L = list, class \&.\&.\&. Args> void \fBsingle_batch\fP (const A &fun, T &accum, const L &mem, Args &&\&.\&.\&. args)"
.br
.RI "Batch multiple iterations of an accumulator function together\&. "
.ti -1c
.RI "template<class T, class A, class L = list, class \&.\&.\&. Args> void \fBbatch\fP (const A &fun, T &accum, const L &mem, Args &&\&.\&.\&. args)"
.br
.RI "Batch multiple iterations of an accumulator function together, threaded\&. "
.ti -1c
.RI "void \fBextend\fP (vector &dest, const std::initializer_list< const list > &source)"
.br
.RI "Batch multiple extend calls into the thread pool\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "BS::thread_pool< BS::tp::wait_deadlock_checks > \fBpool\fP = {}"
.br
.ti -1c
.RI "int \fBinotify\fP = \-1"
.br
.ti -1c
.RI "const std::string \fBhome\fP = std::getenv('HOME')"
.br
.ti -1c
.RI "const std::string \fBruntime\fP = std::getenv('XDG_RUNTIME_DIR')"
.br
.ti -1c
.RI "const std::string \fBsession\fP = std::getenv('DBUS_SESSION_BUS_ADDRESS')"
.br
.ti -1c
.RI "const std::string \fBconfig\fP = std::getenv('XDG_CONFIG_HOME') == nullptr ? home + '/\&.config/' : std::getenv('XDG_CONFIG_HOME')"
.br
.ti -1c
.RI "const std::string \fBcache\fP = std::getenv('XDG_CACHE_HOME') == nullptr ? home + '/\&.cache/' : std::getenv('XDG_CACHE_HOME')"
.br
.ti -1c
.RI "const std::string \fBdata\fP = std::getenv('XDG_DATA_HOME') == nullptr ? home + '/\&.local/\fBshare\fP/' : std::getenv('XDG_DATA_HOME')"
.br
.ti -1c
.RI "const std::string \fBnobody\fP = std::to_string(getpwnam('nobody')\->pw_uid)"
.br
.ti -1c
.RI "const std::string \fBreal\fP = std::to_string(getuid())"
.br
.ti -1c
.RI "std::filesystem::path \fBdata_dir\fP = std::filesystem::path(data) / 'sb'"
.br
.ti -1c
.RI "std::filesystem::path \fBapp_data\fP = ''"
.br
.in -1c
.SH "Detailed Description"
.PP 
Shared functionality\&. 
.SH "Function Documentation"
.PP 
.SS "template<class T, class A, class L = list, class \&.\&.\&. Args> void shared::batch (const A & fun, T & accum, const L & mem, Args &&\&.\&.\&. args)"

.PP
Batch multiple iterations of an accumulator function together, threaded\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP The accumulator type\&. 
.br
\fIA\fP The function type 
.br
\fIL\fP The container holding each value\&. 
.br
\fI\&.\&.\&.Args\fP Additional arguments\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfun\fP The function to call\&. 
.br
\fIaccum\fP The accumulator to append to\&. 
.br
\fImem\fP The list of values to emplace\&. 
.br
\fIargs\fP Additional arguments\&. 
.RE
.PP
\fBWarning\fP
.RS 4
All arguments must be immutable, as instances are threaded together\&. If the ordering matters, or residue arguments are accumulators, use single_batch 
.RE
.PP

.SS "std::string shared::escape (const std::string & in)"

.PP
Escape a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIin\fP The string to escape\&. 
.RE
.PP
\fBReturns\fP
.RS 4
: The escaped string\&. 
.RE
.PP

.SS "void shared::extend (vector & dest, const std::initializer_list< const list > & source)"

.PP
Batch multiple extend calls into the thread pool\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP The list type\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIdest\fP The accumulator\&. 
.br
\fIsource\fP A list of lists that need to be extended\&. 
.RE
.PP

.SS "template<class T> void shared::extend (vector & dest, T source)"

.PP
Extend a container in place\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP The container type for both dest and source\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIdest\fP The container to extend\&. 
.br
\fIsource\fP The values to pull from\&. 
.RE
.PP

.SS "void shared::genv (vector & command, const std::string_view & env)"

.PP
Attach an environment variable to the sandbox\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP The command to append to\&. 
.br
\fIenv\fP The environment variable to add\&. 
.RE
.PP
\fBNote\fP
.RS 4
: The value of the variable is the actual value\&. 
.RE
.PP

.SS "std::string shared::hash (const std::string_view & in)"

.PP
Hash a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIin\fP The input string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The hex digest\&. 
.RE
.PP

.SS "void shared::inotify_wait (const int & wd, const std::string_view & name = \fR''\fP)"

.PP
Wait for an inotify watcher\&. 
.PP
\fBParameters\fP
.RS 4
\fIwd\fP The inotify FD for a specific watch\&. 
.br
\fIname\fP The optional name to look out for\&. 
.RE
.PP

.SS "template<class T> std::string shared::join (const T & list, const char & joiner = \fR' '\fP)"

.PP
Join a vector into a string\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIThe\fP container\&. Defaults to vector of strings, but can also be set\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The list to join\&. 
.br
\fIjoiner\fP The character to join each member\&. 
.RE
.PP
\fBReturns\fP
.RS 4
: The joined string\&. 
.RE
.PP

.SS "void shared::log (const list & msg, const std::string & level = \fR'log'\fP)"

.PP
Log output to console, if verbose\&. 
.PP
\fBParameters\fP
.RS 4
\fImsg\fP A list of strings to be printed\&. 
.RE
.PP

.SS "void shared::merge (set & command, set path)"

.PP
Merge two sets together\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP The set to be extended\&. 
.br
\fIpath\fP The set to merge into the first\&. 
.RE
.PP
\fBNote\fP
.RS 4
This function exists because C++ cannot deduce bracket initializers\&. 
.RE
.PP

.SS "void shared::share (vector & command, const std::string_view & path, const std::string & mode = \fR'ro\-bind'\fP)"

.PP
Share a path with the sandbox using a mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIcommand\fP The command to append to\&. 
.br
\fIpath\fP The path to share\&. 
.br
\fImode\fP The mode to use to share\&. 
.RE
.PP

.SS "template<class T, class A, class L = list, class \&.\&.\&. Args> void shared::single_batch (const A & fun, T & accum, const L & mem, Args &&\&.\&.\&. args)"

.PP
Batch multiple iterations of an accumulator function together\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP The accumulator type\&. 
.br
\fIA\fP The function type\&. 
.br
\fIL\fP The container holding each value\&. 
.br
\fI\&.\&.\&.Args\fP Additional arguments\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfun\fP The function to call 
.br
\fIaccum\fP The accumulator passed to the function\&. 
.br
\fImem\fP The list of values to emplace\&. 
.br
\fIargs\fP Additional arguments\&. 
.RE
.PP

.SS "template<typename T> std::string shared::strip (const std::string_view & in, const T & to_strip)"

.PP
Strip all instance of character from a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIin\fP The input string\&. 
.br
\fIto_strip\fP A list of characters to remove 
.RE
.PP
\fBReturns\fP
.RS 4
The stripped string\&. 
.RE
.PP

.SS "template<typename T> std::string shared::trim (const std::string & in, const T & to_strip)"

.PP
Trim characters from the front and end of a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIin\fP The input string\&. 
.br
\fIto_strip\fP The list of characters to trim\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The trimmed string\&. 
.RE
.PP
\fBNote\fP
.RS 4
trim only removes from the front and end, stopping after encountered a non-to_strip character, whereas strip removes all instances regardless\&. 
.RE
.PP

.SS "set shared::wildcard (const std::string_view & pattern, const std::string_view & path, const list & args = \fR{}\fP)"

.PP
Resolve wildcard patterns\&. 
.PP
\fBParameters\fP
.RS 4
\fIpattern\fP The pattern to resolve 
.br
\fIpath\fP The path to look in 
.br
\fIargs\fP Any additional arguments to find\&. 
.RE
.PP
\fBReturns\fP
.RS 4
: All unique matches\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for SB++ from the source code\&.
